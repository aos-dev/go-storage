// Code generated by go generate via internal/cmd/meta; DO NOT EDIT.
package {{ .Name }}

import (
    "context"

    "github.com/Xuanwo/storage"
    "github.com/Xuanwo/storage/pkg/segment"
    "github.com/Xuanwo/storage/pkg/endpoint"
    "github.com/Xuanwo/storage/pkg/credential"
    "github.com/Xuanwo/storage/types"
    "github.com/Xuanwo/storage/types/pairs"
)

var _ credential.Provider
var _ endpoint.Provider
var _ segment.Segment
var _ storage.Storager

// Type is the type for {{ .Name }}
const Type = "{{ .Name }}"

{{ $Data := . }}

{{- range $name, $data := .Data }}
{{ $cname := $name | camelCase }}
{{- range $k, $v := $data }}
{{ $ck := $k | camelCase }}
type pair{{ $cname }}{{ $ck }} struct {
    // Pre-defined pairs
    Context context.Context

    // Meta-defined pairs
    {{- range $key, $_ := $v }}
    Has{{ $key | camelCase}} bool
    {{ $key | camelCase}}    {{ index $Data.TypeMap $key }}
    {{- end }}
}

func parse{{ $cname }}Pair{{ $ck }}(opts ...*types.Pair) (*pair{{ $cname }}{{ $ck }}, error) {
    result := &pair{{ $cname }}{{ $ck }}{}

    values := make(map[string]interface{})
    for _, v := range opts {
        values[v.Key] = v.Value
    }

    var v interface{}
    var ok bool

    // Parse pre-defined pairs
    v, ok = values[pairs.Context]
    if ok {
        result.Context = v.(context.Context)
    } else {
        result.Context = context.Background()
    }

    // Parse meta-defined pairs
    {{- range $key, $required := $v }}
    v, ok = values[pairs.{{ $key | camelCase}}]
    {{- if $required }}
    if !ok {
        return nil, types.NewErrPairRequired(pairs.{{ $key | camelCase}})
    }
    {{- end }}
    if ok {
        result.Has{{ $key | camelCase}} = true
        result.{{ $key | camelCase}} = v.({{ index $Data.TypeMap $key }})
    }
    {{- end }}
    return result, nil
}
{{- end }}
{{- end }}
