{{ $Data := . }}

{{- range $name, $data := .Data }}
{{- $pn := $name | toPascal }}
{{- range $k, $v := $data }}
{{- $pk := $k | toPascal }}
type pair{{ $pn }}{{ $pk }} struct {
    // Pre-defined pairs
    {{- if $v.Funcs }}
    Context context.Context
    {{- end }}

    // Meta-defined pairs
    {{- range $key, $required := $v.Pairs }}
    {{- if not $required }}
    Has{{ $key | toPascal }} bool
    {{- end }}
    {{ $key | toPascal }}    {{ index $Data.TypeMap $key }}
    {{- end }}
}

func parse{{ $pn }}Pair{{ $pk }}(opts ...*types.Pair) (*pair{{ $pn }}{{ $pk }}, error) {
    result := &pair{{ $pn }}{{ $pk }}{}

    values := make(map[string]interface{})
    for _, v := range opts {
        values[v.Key] = v.Value
    }

    var v interface{}
    var ok bool

    // Parse pre-defined pairs
    {{- if $v.Funcs }}
    v, ok = values[ps.Context]
    if ok {
        result.Context = v.(context.Context)
    } else {
        result.Context = context.Background()
    }
    {{- end }}

    // Parse meta-defined pairs
    {{- range $key, $required := $v.Pairs }}
    {{- $pkey := $key | toPascal }}
    v, ok = values[ps.{{ $pkey }}]
    {{- if $required }}
    if !ok {
        return nil, &services.SeriousPairError{
            Op: "parse",
            Err: services.ErrPairRequired,
            Pairs: []*types.Pair{
                {Key:ps.{{ $pkey }}, Value: nil},
            },
        }
    }
    {{- end }}
    if ok {
        {{- if not $required }}
        result.Has{{ $pkey }} = true
        {{- end }}
        result.{{ $pkey }} = v.({{ index $Data.TypeMap $key }})
    }
    {{- end }}

    {{- if in $v.Pairs "object_func" }}
    // Validate for ObjectFunc
    if result.HasObjectFunc && result.HasFileFunc {
        return nil, &services.SeriousPairError{
            Op: "parse",
            Err: services.ErrPairConflict,
            Pairs: []*types.Pair{
                {Key:ps.ObjectFunc, Value: result.ObjectFunc},
                {Key:ps.FileFunc, Value: result.FileFunc},
            },
        }
    }
    if result.HasObjectFunc && result.HasDirFunc {
        return nil, &services.SeriousPairError{
            Op: "parse",
            Err: services.ErrPairConflict,
            Pairs: []*types.Pair{
                {Key:ps.ObjectFunc, Value: result.ObjectFunc},
                {Key:ps.DirFunc, Value: result.DirFunc},
            },
        }
    }
    if !result.HasObjectFunc && !result.HasFileFunc && !result.HasDirFunc {
        return nil, &services.SeriousPairError{
            Op: "parse",
            Err: services.ErrPairRequired,
            Pairs: []*types.Pair{
                {Key:ps.ObjectFunc, Value: nil},
                {Key:ps.FileFunc, Value: nil},
                {Key:ps.DirFunc, Value: nil},
            },
        }
    }
    {{- end }}
    return result, nil
}
{{- end }}
{{- end }}
