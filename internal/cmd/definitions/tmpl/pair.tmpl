// Code generated by go generate internal/cmd; DO NOT EDIT.
package pairs

import (
    "context"

    "github.com/Xuanwo/storage"
    "github.com/Xuanwo/storage/pkg/segment"
    "github.com/Xuanwo/storage/pkg/endpoint"
    "github.com/Xuanwo/storage/pkg/credential"
    "github.com/Xuanwo/storage/pkg/httpclient"
    "github.com/Xuanwo/storage/types"
)

// All available pairs.
const (
{{- range $_, $v := .Pairs }}
    {{- $pname := $v.Name | toPascal }}
    // {{ $pname }} will {{ $v.Description }}
    {{ $pname }} = "{{ $v.Name }}"
{{- end }}
)

{{- range $_, $v := .Pairs }}
{{- $pname := $v.Name | toPascal }}
// With{{ $pname }} will apply {{ $v.Name }} value to Options
// This pair is used to {{ $v.Description }}
func With{{ $pname }}(v {{ $v.Type }}) *types.Pair {
    return &types.Pair{
        Key: {{ $pname }},
        Value: v,
    }
}
{{- end }}

// Parse will parse a k-v map to pairs slice.
func Parse(m map[string]interface{}) ([]*types.Pair, error) {
    pairs := make([]*types.Pair, 0, len(m))

    var err error

    for k, v := range m {
        var pv interface{}
        switch k {
        {{- range $_, $v := .Pairs }}
            {{- $pname := $v.Name | toPascal }}
            case {{ $pname }}:
                switch rv := v.(type) {
                case {{ $v.Type }}:
                    pv = rv
                {{- if $v.Parser }}
                case string:
                    pv, err = {{$v.Parser}}(rv)
                    if err != nil {
                        return nil, &Error{
                        Op: "parse",
                        Err: err,
                        Key: {{ $pname }},
                        Type: "{{ $v.Type }}",
                        Value: v,
                    }
                }
                {{- end }}
                default:
                    return nil, &Error{
                        Op: "parse",
                        Err: ErrPairTypeMismatch,
                        Key: {{ $pname }},
                        Type: "{{ $v.Type }}",
                        Value: v,
                    }
            }
        {{- end }}
            default:
                continue
        }
        pairs = append(pairs, &types.Pair{Key: k, Value: pv})
    }

    return pairs, nil
}
