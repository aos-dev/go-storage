// Code generated by go generate via internal/cmd/service; DO NOT EDIT.
package {{ .Name }}

import (
    "context"
    "io"

    "github.com/opentracing/opentracing-go"

    "github.com/Xuanwo/storage"
    "github.com/Xuanwo/storage/pkg/segment"
    "github.com/Xuanwo/storage/pkg/endpoint"
    "github.com/Xuanwo/storage/pkg/credential"
    "github.com/Xuanwo/storage/pkg/httpclient"
    "github.com/Xuanwo/storage/services"
    "github.com/Xuanwo/storage/types"
    ps "github.com/Xuanwo/storage/types/pairs"
    "github.com/Xuanwo/storage/types/info"
)

var _ credential.Provider
var _ endpoint.Provider
var _ segment.Segment
var _ storage.Storager
var _ services.ServiceError
var _ httpclient.Options

// Type is the type for {{ .Name }}
const Type = "{{ .Name }}"

// Service available pairs.
const (
{{- range $_, $v := .Pairs }}
    {{- if not $v.Global }}
    {{- $pname := $v.Name | toPascal }}
    // {{ $pname }} will {{ $v.GeneratedDescription }}
    Pair{{ $pname }} = "{{ $.Name }}_{{ $v.Name }}"
    {{- end }}
{{- end }}
)

// Service available infos.
const (
{{- range $_, $v := .Infos }}
    {{- if not $v.Global }}
    {{- $pname := $v.Name | toPascal }}
    {{- if $v.DisplayName }}
        {{- $pname = $v.DisplayName }}
    {{- end }}
    Info{{ $v.Scope | toPascal }}{{ $v.Category | toPascal }}{{ $pname }} = "{{ $.Name }}-{{ $v.Name }}"
    {{- end }}
{{- end }}
)

{{- range $_, $v := .Pairs }}
{{- if not $v.Global }}
{{- $pname := $v.Name | toPascal }}
// With{{ $pname }} will apply {{ $v.Name }} value to Options
// This pair is used to {{ $v.GeneratedDescription }}
func With{{ $pname }}(v {{ $v.Type }}) *types.Pair {
        return &types.Pair{
        Key: Pair{{ $pname }},
        Value: v,
    }
}
{{- end }}
{{- end }}


{{- range $_, $v := .Infos }}
    {{- if not $v.Global }}
    {{ $pname := $v.Name | toPascal }}
    {{- if $v.DisplayName }}
        {{ $pname = $v.DisplayName }}
    {{- end }}
    {{ $serviceName := printf "%s%s" ($v.Scope | toPascal) ($v.Category | toPascal) }}
    // Get{{ $pname }} will get {{ $v.Name }} value from metadata.
    func Get{{ $pname }}(m info.{{ $serviceName }}) ({{ $v.Type }}, bool)  {
    v, ok := m.Get(Info{{ $serviceName }}{{ $pname }})
    if !ok {
    {{- if $v.ZeroValue }}
        return {{ $v.ZeroValue }}, false
    {{- else }}
        return {{ $v.Type | zeroValue }}, false
    {{- end }}
    }
    return v.({{ $v.Type }}), true
    }

    // set{{ $v.Name }} will set {{ $v.Name }} value into metadata.
    func set{{ $pname }}(m info.{{ $serviceName }}, v {{ $v.Type }}) info.{{ $serviceName }} {
    return m.Set(Info{{ $serviceName }}{{ $pname }}, v)
    }
    {{- end }}
{{- end }}


{{- if .Service }}
    {{- template "pairs" makeSlice "service" .Service .Pairs }}
    {{- template "context_func" makeSlice "service" .Service .Name }}
{{- end }}

{{- template "pairs" makeSlice "storage" .Storage .Pairs }}
{{- template "context_func" makeSlice "storage" .Storage .Name }}

{{- define "pair_name" }}
    {{- $key := index . 0 -}}
    {{- $pairs := index . 1 -}}
    {{- if (index $pairs $key).Global -}}
        ps.{{- $key | toPascal -}}
    {{- else -}}
        Pair{{- $key | toPascal -}}
    {{- end -}}
{{- end }}

{{- define "pairs" }}
    {{- $pn := index . 0 | toPascal }}
    {{- $data := index . 1 }}
    {{- $pairs := index . 2 }}

    {{- range $_, $v := $data }}
        {{- $pk := $v.Name | toPascal }}
        var pair{{ $pn }}{{ $pk }}Map = map[string]struct{}{
        // Required pairs
        {{- range $v := $v.Required }}
            {{ template "pair_name" makeSlice $v $pairs -}}: struct{}{},
        {{- end }}
        // Optional pairs
        {{- range $v := $v.Optional }}
            {{ template "pair_name" makeSlice $v $pairs -}}: struct{}{},
        {{- end }}
        // Generated pairs
        {{- range $v := $v.Generated }}
            {{ template "pair_name" makeSlice $v $pairs -}}: struct{}{},
        {{- end }}
        }

        type pair{{ $pn }}{{ $pk }} struct {
        // Required pairs
        {{- range $_, $key := $v.Required }}
            {{ $key | toPascal }}    {{ (index $pairs $key).Type }}
        {{- end }}
        // Optional pairs
        {{- range $_, $key := $v.Optional }}
            Has{{ $key | toPascal }} bool
            {{ $key | toPascal }}    {{ (index $pairs $key).Type }}
        {{- end }}
        // Generated pairs
        {{- range $_, $key := $v.Generated }}
            Has{{ $key | toPascal }} bool
            {{ $key | toPascal }}    {{ (index $pairs $key).Type }}
        {{- end }}
        }

        {{ if hasPrefix $pk "New" -}}
            func parse{{ $pn }}Pair
        {{- else -}}
            func (s *{{ $pn }} ) parsePair
        {{- end -}}
        {{ $pk }}(opts ...*types.Pair) (*pair{{ $pn }}{{ $pk }}, error) {
        result := &pair{{ $pn }}{{ $pk }}{}

        values := make(map[string]interface{})
        for _, v := range opts {
        {{- if not (hasPrefix $pk "New") }}
            if _, ok := pair{{ $pn }}{{ $pk }}Map[v.Key]; !ok {
            return nil, services.NewPairUnsupportedError(v)
            }
        {{- end }}
        values[v.Key] = v.Value
        }

        var v interface{}
        var ok bool

        // Handle required pairs
        {{- range $_, $key := $v.Required }}
        {{- $pkey := $key | toPascal }}
        v, ok = values[{{- template "pair_name" makeSlice $key $pairs -}}]
        if !ok {
            return nil, services.NewPairRequiredError({{- template "pair_name" makeSlice $key $pairs -}})
        }
        if ok {
            result.{{ $pkey }} = v.({{ (index $pairs $key).Type }})
        }
        {{- end }}
        // Handle optional pairs
        {{- range $_, $key := $v.Optional }}
        {{- $pkey := $key | toPascal }}
        v, ok = values[{{- template "pair_name" makeSlice $key $pairs -}}]
        if ok {
            result.Has{{ $pkey }} = true
            result.{{ $pkey }} = v.({{ (index $pairs $key).Type }})
        }
        {{- end }}
        // Handle generated pairs
        {{- range $_, $key := $v.Generated }}
        {{- $pkey := $key | toPascal }}
        v, ok = values[{{- template "pair_name" makeSlice $key $pairs -}}]
        if ok {
            result.Has{{ $pkey }} = true
            result.{{ $pkey }} = v.({{ (index $pairs $key).Type }})
        }
        {{- end }}

        return result, nil
        }
    {{- end }}
{{- end}}

{{- define "context_func" }}
    {{- $name := index . 0}}
    {{- $pn := $name | toPascal }}
    {{- $data := index . 1 }}
    {{- $serviceName := index . 2}}
    {{- range $_, $v := $data }}
        {{ $fn := $v.Func }}
        {{- if $fn }}
            {{- if $fn.HasContext }}
                // {{ $fn.Parent }}WithContext adds context support for {{ $fn.Parent }}.
                func ({{ $fn.Receiver }}) {{ $fn.Parent }}WithContext(ctx context.Context, {{ $fn.Params }}) ( {{ $fn.Returns }}) {
                span, ctx := opentracing.StartSpanFromContext(ctx, "github.com/Xuanwo/storage/services/{{ $serviceName }}.{{ $name }}.{{ $fn.Parent }}")
                defer span.Finish()

                pairs = append(pairs, ps.WithContext(ctx))
                return s.{{ $fn.Parent }}({{ $fn.Caller }})
                }
            {{- end }}
        {{- end }}
    {{- end }}
{{- end }}