// Code generated by go generate internal/cmd/pairs; DO NOT EDIT.
package pairs

import (
    "context"

    "github.com/Xuanwo/storage"
    "github.com/Xuanwo/storage/pkg/segment"
    "github.com/Xuanwo/storage/pkg/endpoint"
    "github.com/Xuanwo/storage/pkg/credential"
    "github.com/Xuanwo/storage/pkg/storageclass"
    "github.com/Xuanwo/storage/types"
)

// All available pairs.
const (
{{- range $k, $v := .Data }}
    // {{ $k | toPascal }} will {{ $v.Description }}
    {{ $k | toPascal }} = "{{ $k }}"
{{- end }}
)

{{- range $k, $v := .Data }}
{{- $pk := $k | toPascal }}
// With{{ $pk }} will apply {{ $k }} value to Options
// This pair is used to {{ $v.Description }}
func With{{ $pk }}(v {{ $v.Type }}) *types.Pair {
    return &types.Pair{
        Key: {{ $pk }},
        Value: v,
    }
}
{{- end }}

// Parse will parse a k-v map to pairs slice.
func Parse(m map[string]interface{}) ([]*types.Pair, error) {
    pairs := make([]*types.Pair, 0, len(m))

    for k, v := range m {
        switch k {
{{- range $k, $v := .Data }}
            case {{ $k | toPascal }}:
                if _, ok := v.({{ $v.Type }}); !ok {
                    return nil, &Error{
                        Op: "parse",
                        Err: ErrPairTypeMismatch,
                        Key: {{ $k | toPascal }},
                        Type: "{{ $v.Type }}",
                        Value: v,
                    }
                }
{{- end }}
            default:
                continue
        }
        pairs = append(pairs, &types.Pair{Key: k, Value: v})
    }

    return pairs, nil
}