// Code generated by go generate internal/cmd; DO NOT EDIT.
package pairs

import (
	"context"

	"github.com/aos-dev/go-storage/v2/pkg/credential"
	"github.com/aos-dev/go-storage/v2/pkg/endpoint"
	"github.com/aos-dev/go-storage/v2/pkg/httpclient"
	. "github.com/aos-dev/go-storage/v2/types"
)

// WithContentMd5 will apply content_md5 value to Options
// ContentMd5
func WithContentMd5(v string) Pair {
	return Pair{
		Key:   "content_md5",
		Value: v,
	}
}

// WithContentType will apply content_type value to Options
// ContentType
func WithContentType(v string) Pair {
	return Pair{
		Key:   "content_type",
		Value: v,
	}
}

// WithContext will apply context value to Options
// Context context in all request
func WithContext(v context.Context) Pair {
	return Pair{
		Key:   "context",
		Value: v,
	}
}

// WithContinuationToken will apply continuation_token value to Options
// ContinuationToken specify the continuation token for list_dir or list_prefix.
func WithContinuationToken(v string) Pair {
	return Pair{
		Key:   "continuation_token",
		Value: v,
	}
}

// WithCredential will apply credential value to Options
// Credential specify how to provide credential for service or storage
func WithCredential(v *credential.Provider) Pair {
	return Pair{
		Key:   "credential",
		Value: v,
	}
}

// WithEndpoint will apply endpoint value to Options
// Endpoint specify how to provide endpoint for service or storage
func WithEndpoint(v endpoint.Provider) Pair {
	return Pair{
		Key:   "endpoint",
		Value: v,
	}
}

// WithExpire will apply expire value to Options
// Expire specify when the url returned by reach will expire
func WithExpire(v int) Pair {
	return Pair{
		Key:   "expire",
		Value: v,
	}
}

// WithHTTPClientOptions will apply http_client_options value to Options
// HTTPClientOptions sepcify the options for the http client
func WithHTTPClientOptions(v *httpclient.Options) Pair {
	return Pair{
		Key:   "http_client_options",
		Value: v,
	}
}

// WithInterceptor will apply interceptor value to Options
// Interceptor
func WithInterceptor(v Interceptor) Pair {
	return Pair{
		Key:   "interceptor",
		Value: v,
	}
}

// WithLocation will apply location value to Options
// Location specify the location for service or storage
func WithLocation(v string) Pair {
	return Pair{
		Key:   "location",
		Value: v,
	}
}

// WithName will apply name value to Options
// Name specify the storage name
func WithName(v string) Pair {
	return Pair{
		Key:   "name",
		Value: v,
	}
}

// WithOffset will apply offset value to Options
// Offset specify offset for this request, storage will seek to this offset before read
func WithOffset(v int64) Pair {
	return Pair{
		Key:   "offset",
		Value: v,
	}
}

// WithPairPolicy will apply pair_policy value to Options
// PairPolicy
func WithPairPolicy(v PairPolicy) Pair {
	return Pair{
		Key:   "pair_policy",
		Value: v,
	}
}

// WithReadCallbackFunc will apply read_callback_func value to Options
// ReadCallbackFunc specify what todo every time we read data from source
func WithReadCallbackFunc(v func([]byte)) Pair {
	return Pair{
		Key:   "read_callback_func",
		Value: v,
	}
}

// WithSize will apply size value to Options
// Size specify size for this request, storage will only read limited content data
func WithSize(v int64) Pair {
	return Pair{
		Key:   "size",
		Value: v,
	}
}

// WithStorageClass will apply storage_class value to Options
// StorageClass
func WithStorageClass(v string) Pair {
	return Pair{
		Key:   "storage_class",
		Value: v,
	}
}

// WithUserAgent will apply user_agent value to Options
// UserAgent specify the custom user-agent from client
func WithUserAgent(v string) Pair {
	return Pair{
		Key:   "user_agent",
		Value: v,
	}
}

// WithWorkDir will apply work_dir value to Options
// WorkDir specify the work dir for service or storage, every operation will be relative to this dir. work_dir MUST start with / for every storage services. work_dir will be default to / if not set.
//  For fs storage service on windows platform, the behavior is undefined.
func WithWorkDir(v string) Pair {
	return Pair{
		Key:   "work_dir",
		Value: v,
	}
}

// Parse will parse a k-v map to pairs slice.
func Parse(m map[string]interface{}) ([]Pair, error) {
	pairs := make([]Pair, 0, len(m))

	var err error

	for k, v := range m {
		var pv interface{}
		switch k {
		case "content_md5":
			switch rv := v.(type) {
			case string:
				pv = rv
			default:
				return nil, &Error{
					Op:    "parse",
					Err:   ErrPairTypeMismatch,
					Key:   "content_md5",
					Type:  "string",
					Value: v,
				}
			}
		case "content_type":
			switch rv := v.(type) {
			case string:
				pv = rv
			default:
				return nil, &Error{
					Op:    "parse",
					Err:   ErrPairTypeMismatch,
					Key:   "content_type",
					Type:  "string",
					Value: v,
				}
			}
		case "context":
			switch rv := v.(type) {
			case context.Context:
				pv = rv
			default:
				return nil, &Error{
					Op:    "parse",
					Err:   ErrPairTypeMismatch,
					Key:   "context",
					Type:  "context.Context",
					Value: v,
				}
			}
		case "continuation_token":
			switch rv := v.(type) {
			case string:
				pv = rv
			default:
				return nil, &Error{
					Op:    "parse",
					Err:   ErrPairTypeMismatch,
					Key:   "continuation_token",
					Type:  "string",
					Value: v,
				}
			}
		case "credential":
			switch rv := v.(type) {
			case *credential.Provider:
				pv = rv
			case string:
				pv, err = credential.Parse(rv)
				if err != nil {
					return nil, &Error{
						Op:    "parse",
						Err:   err,
						Key:   "credential",
						Type:  "*credential.Provider",
						Value: v,
					}
				}
			default:
				return nil, &Error{
					Op:    "parse",
					Err:   ErrPairTypeMismatch,
					Key:   "credential",
					Type:  "*credential.Provider",
					Value: v,
				}
			}
		case "endpoint":
			switch rv := v.(type) {
			case endpoint.Provider:
				pv = rv
			case string:
				pv, err = endpoint.Parse(rv)
				if err != nil {
					return nil, &Error{
						Op:    "parse",
						Err:   err,
						Key:   "endpoint",
						Type:  "endpoint.Provider",
						Value: v,
					}
				}
			default:
				return nil, &Error{
					Op:    "parse",
					Err:   ErrPairTypeMismatch,
					Key:   "endpoint",
					Type:  "endpoint.Provider",
					Value: v,
				}
			}
		case "expire":
			switch rv := v.(type) {
			case int:
				pv = rv
			case string:
				pv, err = parseInt(rv)
				if err != nil {
					return nil, &Error{
						Op:    "parse",
						Err:   err,
						Key:   "expire",
						Type:  "int",
						Value: v,
					}
				}
			default:
				return nil, &Error{
					Op:    "parse",
					Err:   ErrPairTypeMismatch,
					Key:   "expire",
					Type:  "int",
					Value: v,
				}
			}
		case "http_client_options":
			switch rv := v.(type) {
			case *httpclient.Options:
				pv = rv
			default:
				return nil, &Error{
					Op:    "parse",
					Err:   ErrPairTypeMismatch,
					Key:   "http_client_options",
					Type:  "*httpclient.Options",
					Value: v,
				}
			}
		case "interceptor":
			switch rv := v.(type) {
			case Interceptor:
				pv = rv
			default:
				return nil, &Error{
					Op:    "parse",
					Err:   ErrPairTypeMismatch,
					Key:   "interceptor",
					Type:  "Interceptor",
					Value: v,
				}
			}
		case "location":
			switch rv := v.(type) {
			case string:
				pv = rv
			default:
				return nil, &Error{
					Op:    "parse",
					Err:   ErrPairTypeMismatch,
					Key:   "location",
					Type:  "string",
					Value: v,
				}
			}
		case "name":
			switch rv := v.(type) {
			case string:
				pv = rv
			default:
				return nil, &Error{
					Op:    "parse",
					Err:   ErrPairTypeMismatch,
					Key:   "name",
					Type:  "string",
					Value: v,
				}
			}
		case "offset":
			switch rv := v.(type) {
			case int64:
				pv = rv
			case string:
				pv, err = parseInt64(rv)
				if err != nil {
					return nil, &Error{
						Op:    "parse",
						Err:   err,
						Key:   "offset",
						Type:  "int64",
						Value: v,
					}
				}
			default:
				return nil, &Error{
					Op:    "parse",
					Err:   ErrPairTypeMismatch,
					Key:   "offset",
					Type:  "int64",
					Value: v,
				}
			}
		case "pair_policy":
			switch rv := v.(type) {
			case PairPolicy:
				pv = rv
			default:
				return nil, &Error{
					Op:    "parse",
					Err:   ErrPairTypeMismatch,
					Key:   "pair_policy",
					Type:  "PairPolicy",
					Value: v,
				}
			}
		case "read_callback_func":
			switch rv := v.(type) {
			case func([]byte):
				pv = rv
			default:
				return nil, &Error{
					Op:    "parse",
					Err:   ErrPairTypeMismatch,
					Key:   "read_callback_func",
					Type:  "func([]byte)",
					Value: v,
				}
			}
		case "size":
			switch rv := v.(type) {
			case int64:
				pv = rv
			case string:
				pv, err = parseInt64(rv)
				if err != nil {
					return nil, &Error{
						Op:    "parse",
						Err:   err,
						Key:   "size",
						Type:  "int64",
						Value: v,
					}
				}
			default:
				return nil, &Error{
					Op:    "parse",
					Err:   ErrPairTypeMismatch,
					Key:   "size",
					Type:  "int64",
					Value: v,
				}
			}
		case "storage_class":
			switch rv := v.(type) {
			case string:
				pv = rv
			default:
				return nil, &Error{
					Op:    "parse",
					Err:   ErrPairTypeMismatch,
					Key:   "storage_class",
					Type:  "string",
					Value: v,
				}
			}
		case "user_agent":
			switch rv := v.(type) {
			case string:
				pv = rv
			default:
				return nil, &Error{
					Op:    "parse",
					Err:   ErrPairTypeMismatch,
					Key:   "user_agent",
					Type:  "string",
					Value: v,
				}
			}
		case "work_dir":
			switch rv := v.(type) {
			case string:
				pv = rv
			default:
				return nil, &Error{
					Op:    "parse",
					Err:   ErrPairTypeMismatch,
					Key:   "work_dir",
					Type:  "string",
					Value: v,
				}
			}
		default:
			continue
		}
		pairs = append(pairs, Pair{Key: k, Value: pv})
	}

	return pairs, nil
}
