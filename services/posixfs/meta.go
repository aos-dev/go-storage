// Code generated by go generate via internal/cmd/meta_gen; DO NOT EDIT.
package posixfs

import (
	"github.com/Xuanwo/storage"
	"github.com/Xuanwo/storage/types"
)

// StoragerType is the storager type for posixfs
const StoragerType = types.StoragerType("posixfs")

var notAllowedStorageAction = map[string]struct{}{
	"reach": struct{}{},
}

var allowedStoragePairs = map[string]map[string]struct{}{
	storage.ActionDelete: {
		"recursive": struct{}{},
	},
	storage.ActionInit: {
		"base": struct{}{},
	},
	storage.ActionListDir: {
		"recursive": struct{}{},
	},
	storage.ActionRead: {
		"offset": struct{}{},
		"size":   struct{}{},
	},
	storage.ActionWrite: {
		"size": struct{}{},
	},
}

var allowedServicePairs = map[string]map[string]struct{}{}

// Capable implements Storager.Capable().
func (c *Client) Capable(action string, pair ...string) bool {
	if _, ok := notAllowedStorageAction[action]; ok {
		return false
	}
	// If no pair input, we only need to check action.
	if len(pair) == 0 {
		return true
	}

	if _, ok := allowedStoragePairs[action]; !ok {
		return false
	}
	for _, v := range pair {
		if _, ok := allowedStoragePairs[action][v]; !ok {
			return false
		}
	}
	return true
}

type pairStorageDelete struct {
	HasRecursive bool
	Recursive    bool
}

func parseStoragePairDelete(opts ...*types.Pair) (*pairStorageDelete, error) {
	result := &pairStorageDelete{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowedStoragePairs[storage.ActionDelete]; !ok {
			continue
		}
		if _, ok := allowedStoragePairs[storage.ActionDelete][v.Key]; !ok {
			continue
		}
		values[v.Key] = v.Value
	}
	var v interface{}
	var ok bool
	v, ok = values[types.Recursive]
	if ok {
		result.HasRecursive = true
		result.Recursive = v.(bool)
	}
	return result, nil
}

type pairStorageInit struct {
	HasBase bool
	Base    string
}

func parseStoragePairInit(opts ...*types.Pair) (*pairStorageInit, error) {
	result := &pairStorageInit{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowedStoragePairs[storage.ActionInit]; !ok {
			continue
		}
		if _, ok := allowedStoragePairs[storage.ActionInit][v.Key]; !ok {
			continue
		}
		values[v.Key] = v.Value
	}
	var v interface{}
	var ok bool
	v, ok = values[types.Base]
	if !ok {
		return nil, types.NewErrPairRequired(types.Base)
	}
	if ok {
		result.HasBase = true
		result.Base = v.(string)
	}
	return result, nil
}

type pairStorageListDir struct {
	HasRecursive bool
	Recursive    bool
}

func parseStoragePairListDir(opts ...*types.Pair) (*pairStorageListDir, error) {
	result := &pairStorageListDir{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowedStoragePairs[storage.ActionListDir]; !ok {
			continue
		}
		if _, ok := allowedStoragePairs[storage.ActionListDir][v.Key]; !ok {
			continue
		}
		values[v.Key] = v.Value
	}
	var v interface{}
	var ok bool
	v, ok = values[types.Recursive]
	if ok {
		result.HasRecursive = true
		result.Recursive = v.(bool)
	}
	return result, nil
}

type pairStorageRead struct {
	HasOffset bool
	Offset    int64
	HasSize   bool
	Size      int64
}

func parseStoragePairRead(opts ...*types.Pair) (*pairStorageRead, error) {
	result := &pairStorageRead{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowedStoragePairs[storage.ActionRead]; !ok {
			continue
		}
		if _, ok := allowedStoragePairs[storage.ActionRead][v.Key]; !ok {
			continue
		}
		values[v.Key] = v.Value
	}
	var v interface{}
	var ok bool
	v, ok = values[types.Offset]
	if ok {
		result.HasOffset = true
		result.Offset = v.(int64)
	}
	v, ok = values[types.Size]
	if ok {
		result.HasSize = true
		result.Size = v.(int64)
	}
	return result, nil
}

type pairStorageWrite struct {
	HasSize bool
	Size    int64
}

func parseStoragePairWrite(opts ...*types.Pair) (*pairStorageWrite, error) {
	result := &pairStorageWrite{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := allowedStoragePairs[storage.ActionWrite]; !ok {
			continue
		}
		if _, ok := allowedStoragePairs[storage.ActionWrite][v.Key]; !ok {
			continue
		}
		values[v.Key] = v.Value
	}
	var v interface{}
	var ok bool
	v, ok = values[types.Size]
	if ok {
		result.HasSize = true
		result.Size = v.(int64)
	}
	return result, nil
}
