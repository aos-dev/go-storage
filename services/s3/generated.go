// Code generated by go generate via internal/cmd/service; DO NOT EDIT.
package s3

import (
	"context"
	"io"

	"github.com/opentracing/opentracing-go"

	"github.com/Xuanwo/storage"
	"github.com/Xuanwo/storage/pkg/credential"
	"github.com/Xuanwo/storage/pkg/endpoint"
	"github.com/Xuanwo/storage/pkg/httpclient"
	"github.com/Xuanwo/storage/pkg/segment"
	"github.com/Xuanwo/storage/pkg/storageclass"
	"github.com/Xuanwo/storage/services"
	"github.com/Xuanwo/storage/types"
	"github.com/Xuanwo/storage/types/metadata"
	ps "github.com/Xuanwo/storage/types/pairs"
)

var _ credential.Provider
var _ endpoint.Provider
var _ segment.Segment
var _ storage.Storager
var _ storageclass.Type
var _ services.ServiceError
var _ httpclient.Options

// Type is the type for s3
const Type = "s3"

var pairServiceCreateMap = map[string]struct{}{
	// Meta-defined pairs
	"location": struct{}{},
	"context":  struct{}{},
}

type pairServiceCreate struct {
	// Pre-defined pairs
	Context context.Context

	// Meta-defined pairs
	Location   string
	HasContext bool
	Context    context.Context
}

func (s *Service) parsePairCreate(opts ...*types.Pair) (*pairServiceCreate, error) {
	result := &pairServiceCreate{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := pairServiceCreateMap[v.Key]; !ok {
			return nil, services.NewPairUnsupportedError(v)
		}
		values[v.Key] = v.Value
	}

	var v interface{}
	var ok bool

	// Parse pre-defined pairs
	v, ok = values[ps.Context]
	if ok {
		result.Context = v.(context.Context)
	} else {
		result.Context = context.Background()
	}

	// Parse meta-defined pairs
	v, ok = values[ps.Location]
	if !ok {
		return nil, services.NewPairRequiredError(ps.Location)
	}
	if ok {
		result.Location = v.(string)
	}
	v, ok = values[ps.Context]
	if ok {
		result.HasContext = true
		result.Context = v.(context.Context)
	}

	return result, nil
}

var pairServiceDeleteMap = map[string]struct{}{
	// Meta-defined pairs
	"context":  struct{}{},
	"location": struct{}{},
}

type pairServiceDelete struct {
	// Pre-defined pairs
	Context context.Context

	// Meta-defined pairs
	HasContext  bool
	Context     context.Context
	HasLocation bool
	Location    string
}

func (s *Service) parsePairDelete(opts ...*types.Pair) (*pairServiceDelete, error) {
	result := &pairServiceDelete{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := pairServiceDeleteMap[v.Key]; !ok {
			return nil, services.NewPairUnsupportedError(v)
		}
		values[v.Key] = v.Value
	}

	var v interface{}
	var ok bool

	// Parse pre-defined pairs
	v, ok = values[ps.Context]
	if ok {
		result.Context = v.(context.Context)
	} else {
		result.Context = context.Background()
	}

	// Parse meta-defined pairs
	v, ok = values[ps.Context]
	if ok {
		result.HasContext = true
		result.Context = v.(context.Context)
	}
	v, ok = values[ps.Location]
	if ok {
		result.HasLocation = true
		result.Location = v.(string)
	}

	return result, nil
}

var pairServiceGetMap = map[string]struct{}{
	// Meta-defined pairs
	"context":  struct{}{},
	"location": struct{}{},
}

type pairServiceGet struct {
	// Pre-defined pairs
	Context context.Context

	// Meta-defined pairs
	HasContext  bool
	Context     context.Context
	HasLocation bool
	Location    string
}

func (s *Service) parsePairGet(opts ...*types.Pair) (*pairServiceGet, error) {
	result := &pairServiceGet{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := pairServiceGetMap[v.Key]; !ok {
			return nil, services.NewPairUnsupportedError(v)
		}
		values[v.Key] = v.Value
	}

	var v interface{}
	var ok bool

	// Parse pre-defined pairs
	v, ok = values[ps.Context]
	if ok {
		result.Context = v.(context.Context)
	} else {
		result.Context = context.Background()
	}

	// Parse meta-defined pairs
	v, ok = values[ps.Context]
	if ok {
		result.HasContext = true
		result.Context = v.(context.Context)
	}
	v, ok = values[ps.Location]
	if ok {
		result.HasLocation = true
		result.Location = v.(string)
	}

	return result, nil
}

var pairServiceListMap = map[string]struct{}{
	// Meta-defined pairs
	"storager_func": struct{}{},
	"context":       struct{}{},
}

type pairServiceList struct {
	// Pre-defined pairs
	Context context.Context

	// Meta-defined pairs
	StoragerFunc storage.StoragerFunc
	HasContext   bool
	Context      context.Context
}

func (s *Service) parsePairList(opts ...*types.Pair) (*pairServiceList, error) {
	result := &pairServiceList{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := pairServiceListMap[v.Key]; !ok {
			return nil, services.NewPairUnsupportedError(v)
		}
		values[v.Key] = v.Value
	}

	var v interface{}
	var ok bool

	// Parse pre-defined pairs
	v, ok = values[ps.Context]
	if ok {
		result.Context = v.(context.Context)
	} else {
		result.Context = context.Background()
	}

	// Parse meta-defined pairs
	v, ok = values[ps.StoragerFunc]
	if !ok {
		return nil, services.NewPairRequiredError(ps.StoragerFunc)
	}
	if ok {
		result.StoragerFunc = v.(storage.StoragerFunc)
	}
	v, ok = values[ps.Context]
	if ok {
		result.HasContext = true
		result.Context = v.(context.Context)
	}

	return result, nil
}

var pairServiceNewMap = map[string]struct{}{
	// Meta-defined pairs
	"credential":          struct{}{},
	"context":             struct{}{},
	"endpoint":            struct{}{},
	"http_client_options": struct{}{},
}

type pairServiceNew struct {
	// Pre-defined pairs

	// Meta-defined pairs
	Credential           *credential.Provider
	HasContext           bool
	Context              context.Context
	HasEndpoint          bool
	Endpoint             endpoint.Provider
	HasHTTPClientOptions bool
	HTTPClientOptions    *httpclient.Options
}

func parseServicePairNew(opts ...*types.Pair) (*pairServiceNew, error) {
	result := &pairServiceNew{}

	values := make(map[string]interface{})
	for _, v := range opts {
		values[v.Key] = v.Value
	}

	var v interface{}
	var ok bool

	// Parse pre-defined pairs

	// Parse meta-defined pairs
	v, ok = values[ps.Credential]
	if !ok {
		return nil, services.NewPairRequiredError(ps.Credential)
	}
	if ok {
		result.Credential = v.(*credential.Provider)
	}
	v, ok = values[ps.Context]
	if ok {
		result.HasContext = true
		result.Context = v.(context.Context)
	}
	v, ok = values[ps.Endpoint]
	if ok {
		result.HasEndpoint = true
		result.Endpoint = v.(endpoint.Provider)
	}
	v, ok = values[ps.HTTPClientOptions]
	if ok {
		result.HasHTTPClientOptions = true
		result.HTTPClientOptions = v.(*httpclient.Options)
	}

	return result, nil
}

var pairStorageAbortSegmentMap = map[string]struct{}{
	// Meta-defined pairs
	"context": struct{}{},
}

type pairStorageAbortSegment struct {
	// Pre-defined pairs
	Context context.Context

	// Meta-defined pairs
	HasContext bool
	Context    context.Context
}

func (s *Storage) parsePairAbortSegment(opts ...*types.Pair) (*pairStorageAbortSegment, error) {
	result := &pairStorageAbortSegment{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := pairStorageAbortSegmentMap[v.Key]; !ok {
			return nil, services.NewPairUnsupportedError(v)
		}
		values[v.Key] = v.Value
	}

	var v interface{}
	var ok bool

	// Parse pre-defined pairs
	v, ok = values[ps.Context]
	if ok {
		result.Context = v.(context.Context)
	} else {
		result.Context = context.Background()
	}

	// Parse meta-defined pairs
	v, ok = values[ps.Context]
	if ok {
		result.HasContext = true
		result.Context = v.(context.Context)
	}

	return result, nil
}

var pairStorageCompleteSegmentMap = map[string]struct{}{
	// Meta-defined pairs
	"context": struct{}{},
}

type pairStorageCompleteSegment struct {
	// Pre-defined pairs
	Context context.Context

	// Meta-defined pairs
	HasContext bool
	Context    context.Context
}

func (s *Storage) parsePairCompleteSegment(opts ...*types.Pair) (*pairStorageCompleteSegment, error) {
	result := &pairStorageCompleteSegment{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := pairStorageCompleteSegmentMap[v.Key]; !ok {
			return nil, services.NewPairUnsupportedError(v)
		}
		values[v.Key] = v.Value
	}

	var v interface{}
	var ok bool

	// Parse pre-defined pairs
	v, ok = values[ps.Context]
	if ok {
		result.Context = v.(context.Context)
	} else {
		result.Context = context.Background()
	}

	// Parse meta-defined pairs
	v, ok = values[ps.Context]
	if ok {
		result.HasContext = true
		result.Context = v.(context.Context)
	}

	return result, nil
}

var pairStorageCreateMap = map[string]struct{}{
	// Meta-defined pairs
	"location": struct{}{},
	"context":  struct{}{},
}

type pairStorageCreate struct {
	// Pre-defined pairs

	// Meta-defined pairs
	Location   string
	HasContext bool
	Context    context.Context
}

func (s *Storage) parsePairCreate(opts ...*types.Pair) (*pairStorageCreate, error) {
	result := &pairStorageCreate{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := pairStorageCreateMap[v.Key]; !ok {
			return nil, services.NewPairUnsupportedError(v)
		}
		values[v.Key] = v.Value
	}

	var v interface{}
	var ok bool

	// Parse pre-defined pairs

	// Parse meta-defined pairs
	v, ok = values[ps.Location]
	if !ok {
		return nil, services.NewPairRequiredError(ps.Location)
	}
	if ok {
		result.Location = v.(string)
	}
	v, ok = values[ps.Context]
	if ok {
		result.HasContext = true
		result.Context = v.(context.Context)
	}

	return result, nil
}

var pairStorageDeleteMap = map[string]struct{}{
	// Meta-defined pairs
	"context":  struct{}{},
	"location": struct{}{},
}

type pairStorageDelete struct {
	// Pre-defined pairs
	Context context.Context

	// Meta-defined pairs
	HasContext  bool
	Context     context.Context
	HasLocation bool
	Location    string
}

func (s *Storage) parsePairDelete(opts ...*types.Pair) (*pairStorageDelete, error) {
	result := &pairStorageDelete{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := pairStorageDeleteMap[v.Key]; !ok {
			return nil, services.NewPairUnsupportedError(v)
		}
		values[v.Key] = v.Value
	}

	var v interface{}
	var ok bool

	// Parse pre-defined pairs
	v, ok = values[ps.Context]
	if ok {
		result.Context = v.(context.Context)
	} else {
		result.Context = context.Background()
	}

	// Parse meta-defined pairs
	v, ok = values[ps.Context]
	if ok {
		result.HasContext = true
		result.Context = v.(context.Context)
	}
	v, ok = values[ps.Location]
	if ok {
		result.HasLocation = true
		result.Location = v.(string)
	}

	return result, nil
}

var pairStorageGetMap = map[string]struct{}{
	// Meta-defined pairs
	"context":  struct{}{},
	"location": struct{}{},
}

type pairStorageGet struct {
	// Pre-defined pairs

	// Meta-defined pairs
	HasContext  bool
	Context     context.Context
	HasLocation bool
	Location    string
}

func (s *Storage) parsePairGet(opts ...*types.Pair) (*pairStorageGet, error) {
	result := &pairStorageGet{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := pairStorageGetMap[v.Key]; !ok {
			return nil, services.NewPairUnsupportedError(v)
		}
		values[v.Key] = v.Value
	}

	var v interface{}
	var ok bool

	// Parse pre-defined pairs

	// Parse meta-defined pairs
	v, ok = values[ps.Context]
	if ok {
		result.HasContext = true
		result.Context = v.(context.Context)
	}
	v, ok = values[ps.Location]
	if ok {
		result.HasLocation = true
		result.Location = v.(string)
	}

	return result, nil
}

var pairStorageInitIndexSegmentMap = map[string]struct{}{
	// Meta-defined pairs
	"context": struct{}{},
}

type pairStorageInitIndexSegment struct {
	// Pre-defined pairs
	Context context.Context

	// Meta-defined pairs
	HasContext bool
	Context    context.Context
}

func (s *Storage) parsePairInitIndexSegment(opts ...*types.Pair) (*pairStorageInitIndexSegment, error) {
	result := &pairStorageInitIndexSegment{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := pairStorageInitIndexSegmentMap[v.Key]; !ok {
			return nil, services.NewPairUnsupportedError(v)
		}
		values[v.Key] = v.Value
	}

	var v interface{}
	var ok bool

	// Parse pre-defined pairs
	v, ok = values[ps.Context]
	if ok {
		result.Context = v.(context.Context)
	} else {
		result.Context = context.Background()
	}

	// Parse meta-defined pairs
	v, ok = values[ps.Context]
	if ok {
		result.HasContext = true
		result.Context = v.(context.Context)
	}

	return result, nil
}

var pairStorageListMap = map[string]struct{}{
	// Meta-defined pairs
	"storager_func": struct{}{},
	"context":       struct{}{},
}

type pairStorageList struct {
	// Pre-defined pairs

	// Meta-defined pairs
	StoragerFunc storage.StoragerFunc
	HasContext   bool
	Context      context.Context
}

func (s *Storage) parsePairList(opts ...*types.Pair) (*pairStorageList, error) {
	result := &pairStorageList{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := pairStorageListMap[v.Key]; !ok {
			return nil, services.NewPairUnsupportedError(v)
		}
		values[v.Key] = v.Value
	}

	var v interface{}
	var ok bool

	// Parse pre-defined pairs

	// Parse meta-defined pairs
	v, ok = values[ps.StoragerFunc]
	if !ok {
		return nil, services.NewPairRequiredError(ps.StoragerFunc)
	}
	if ok {
		result.StoragerFunc = v.(storage.StoragerFunc)
	}
	v, ok = values[ps.Context]
	if ok {
		result.HasContext = true
		result.Context = v.(context.Context)
	}

	return result, nil
}

var pairStorageListDirMap = map[string]struct{}{
	// Meta-defined pairs
	"context": struct{}{},
}

type pairStorageListDir struct {
	// Pre-defined pairs
	Context context.Context

	// Meta-defined pairs
	HasContext bool
	Context    context.Context
}

func (s *Storage) parsePairListDir(opts ...*types.Pair) (*pairStorageListDir, error) {
	result := &pairStorageListDir{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := pairStorageListDirMap[v.Key]; !ok {
			return nil, services.NewPairUnsupportedError(v)
		}
		values[v.Key] = v.Value
	}

	var v interface{}
	var ok bool

	// Parse pre-defined pairs
	v, ok = values[ps.Context]
	if ok {
		result.Context = v.(context.Context)
	} else {
		result.Context = context.Background()
	}

	// Parse meta-defined pairs
	v, ok = values[ps.Context]
	if ok {
		result.HasContext = true
		result.Context = v.(context.Context)
	}

	return result, nil
}

var pairStorageListPrefixMap = map[string]struct{}{
	// Meta-defined pairs
	"context": struct{}{},
}

type pairStorageListPrefix struct {
	// Pre-defined pairs
	Context context.Context

	// Meta-defined pairs
	HasContext bool
	Context    context.Context
}

func (s *Storage) parsePairListPrefix(opts ...*types.Pair) (*pairStorageListPrefix, error) {
	result := &pairStorageListPrefix{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := pairStorageListPrefixMap[v.Key]; !ok {
			return nil, services.NewPairUnsupportedError(v)
		}
		values[v.Key] = v.Value
	}

	var v interface{}
	var ok bool

	// Parse pre-defined pairs
	v, ok = values[ps.Context]
	if ok {
		result.Context = v.(context.Context)
	} else {
		result.Context = context.Background()
	}

	// Parse meta-defined pairs
	v, ok = values[ps.Context]
	if ok {
		result.HasContext = true
		result.Context = v.(context.Context)
	}

	return result, nil
}

var pairStorageListPrefixSegmentsMap = map[string]struct{}{
	// Meta-defined pairs
	"segment_func": struct{}{},
	"context":      struct{}{},
}

type pairStorageListPrefixSegments struct {
	// Pre-defined pairs
	Context context.Context

	// Meta-defined pairs
	SegmentFunc segment.Func
	HasContext  bool
	Context     context.Context
}

func (s *Storage) parsePairListPrefixSegments(opts ...*types.Pair) (*pairStorageListPrefixSegments, error) {
	result := &pairStorageListPrefixSegments{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := pairStorageListPrefixSegmentsMap[v.Key]; !ok {
			return nil, services.NewPairUnsupportedError(v)
		}
		values[v.Key] = v.Value
	}

	var v interface{}
	var ok bool

	// Parse pre-defined pairs
	v, ok = values[ps.Context]
	if ok {
		result.Context = v.(context.Context)
	} else {
		result.Context = context.Background()
	}

	// Parse meta-defined pairs
	v, ok = values[ps.SegmentFunc]
	if !ok {
		return nil, services.NewPairRequiredError(ps.SegmentFunc)
	}
	if ok {
		result.SegmentFunc = v.(segment.Func)
	}
	v, ok = values[ps.Context]
	if ok {
		result.HasContext = true
		result.Context = v.(context.Context)
	}

	return result, nil
}

var pairStorageMetadataMap = map[string]struct{}{
	// Meta-defined pairs
	"context": struct{}{},
}

type pairStorageMetadata struct {
	// Pre-defined pairs
	Context context.Context

	// Meta-defined pairs
	HasContext bool
	Context    context.Context
}

func (s *Storage) parsePairMetadata(opts ...*types.Pair) (*pairStorageMetadata, error) {
	result := &pairStorageMetadata{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := pairStorageMetadataMap[v.Key]; !ok {
			return nil, services.NewPairUnsupportedError(v)
		}
		values[v.Key] = v.Value
	}

	var v interface{}
	var ok bool

	// Parse pre-defined pairs
	v, ok = values[ps.Context]
	if ok {
		result.Context = v.(context.Context)
	} else {
		result.Context = context.Background()
	}

	// Parse meta-defined pairs
	v, ok = values[ps.Context]
	if ok {
		result.HasContext = true
		result.Context = v.(context.Context)
	}

	return result, nil
}

var pairStorageNewMap = map[string]struct{}{
	// Meta-defined pairs
	"credential":          struct{}{},
	"context":             struct{}{},
	"endpoint":            struct{}{},
	"http_client_options": struct{}{},
}

type pairStorageNew struct {
	// Pre-defined pairs

	// Meta-defined pairs
	Credential           *credential.Provider
	HasContext           bool
	Context              context.Context
	HasEndpoint          bool
	Endpoint             endpoint.Provider
	HasHTTPClientOptions bool
	HTTPClientOptions    *httpclient.Options
}

func parseStoragePairNew(opts ...*types.Pair) (*pairStorageNew, error) {
	result := &pairStorageNew{}

	values := make(map[string]interface{})
	for _, v := range opts {
		values[v.Key] = v.Value
	}

	var v interface{}
	var ok bool

	// Parse pre-defined pairs

	// Parse meta-defined pairs
	v, ok = values[ps.Credential]
	if !ok {
		return nil, services.NewPairRequiredError(ps.Credential)
	}
	if ok {
		result.Credential = v.(*credential.Provider)
	}
	v, ok = values[ps.Context]
	if ok {
		result.HasContext = true
		result.Context = v.(context.Context)
	}
	v, ok = values[ps.Endpoint]
	if ok {
		result.HasEndpoint = true
		result.Endpoint = v.(endpoint.Provider)
	}
	v, ok = values[ps.HTTPClientOptions]
	if ok {
		result.HasHTTPClientOptions = true
		result.HTTPClientOptions = v.(*httpclient.Options)
	}

	return result, nil
}

var pairStorageReadMap = map[string]struct{}{
	// Meta-defined pairs
	"context":            struct{}{},
	"read_callback_func": struct{}{},
}

type pairStorageRead struct {
	// Pre-defined pairs
	Context context.Context

	// Meta-defined pairs
	HasContext          bool
	Context             context.Context
	HasReadCallbackFunc bool
	ReadCallbackFunc    func([]byte)
}

func (s *Storage) parsePairRead(opts ...*types.Pair) (*pairStorageRead, error) {
	result := &pairStorageRead{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := pairStorageReadMap[v.Key]; !ok {
			return nil, services.NewPairUnsupportedError(v)
		}
		values[v.Key] = v.Value
	}

	var v interface{}
	var ok bool

	// Parse pre-defined pairs
	v, ok = values[ps.Context]
	if ok {
		result.Context = v.(context.Context)
	} else {
		result.Context = context.Background()
	}

	// Parse meta-defined pairs
	v, ok = values[ps.Context]
	if ok {
		result.HasContext = true
		result.Context = v.(context.Context)
	}
	v, ok = values[ps.ReadCallbackFunc]
	if ok {
		result.HasReadCallbackFunc = true
		result.ReadCallbackFunc = v.(func([]byte))
	}

	return result, nil
}

var pairStorageStatMap = map[string]struct{}{
	// Meta-defined pairs
	"context": struct{}{},
}

type pairStorageStat struct {
	// Pre-defined pairs
	Context context.Context

	// Meta-defined pairs
	HasContext bool
	Context    context.Context
}

func (s *Storage) parsePairStat(opts ...*types.Pair) (*pairStorageStat, error) {
	result := &pairStorageStat{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := pairStorageStatMap[v.Key]; !ok {
			return nil, services.NewPairUnsupportedError(v)
		}
		values[v.Key] = v.Value
	}

	var v interface{}
	var ok bool

	// Parse pre-defined pairs
	v, ok = values[ps.Context]
	if ok {
		result.Context = v.(context.Context)
	} else {
		result.Context = context.Background()
	}

	// Parse meta-defined pairs
	v, ok = values[ps.Context]
	if ok {
		result.HasContext = true
		result.Context = v.(context.Context)
	}

	return result, nil
}

var pairStorageWriteMap = map[string]struct{}{
	// Meta-defined pairs
	"context":            struct{}{},
	"read_callback_func": struct{}{},
}

type pairStorageWrite struct {
	// Pre-defined pairs
	Context context.Context

	// Meta-defined pairs
	HasContext          bool
	Context             context.Context
	HasReadCallbackFunc bool
	ReadCallbackFunc    func([]byte)
}

func (s *Storage) parsePairWrite(opts ...*types.Pair) (*pairStorageWrite, error) {
	result := &pairStorageWrite{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := pairStorageWriteMap[v.Key]; !ok {
			return nil, services.NewPairUnsupportedError(v)
		}
		values[v.Key] = v.Value
	}

	var v interface{}
	var ok bool

	// Parse pre-defined pairs
	v, ok = values[ps.Context]
	if ok {
		result.Context = v.(context.Context)
	} else {
		result.Context = context.Background()
	}

	// Parse meta-defined pairs
	v, ok = values[ps.Context]
	if ok {
		result.HasContext = true
		result.Context = v.(context.Context)
	}
	v, ok = values[ps.ReadCallbackFunc]
	if ok {
		result.HasReadCallbackFunc = true
		result.ReadCallbackFunc = v.(func([]byte))
	}

	return result, nil
}

var pairStorageWriteIndexSegmentMap = map[string]struct{}{
	// Meta-defined pairs
	"context":            struct{}{},
	"read_callback_func": struct{}{},
}

type pairStorageWriteIndexSegment struct {
	// Pre-defined pairs
	Context context.Context

	// Meta-defined pairs
	HasContext          bool
	Context             context.Context
	HasReadCallbackFunc bool
	ReadCallbackFunc    func([]byte)
}

func (s *Storage) parsePairWriteIndexSegment(opts ...*types.Pair) (*pairStorageWriteIndexSegment, error) {
	result := &pairStorageWriteIndexSegment{}

	values := make(map[string]interface{})
	for _, v := range opts {
		if _, ok := pairStorageWriteIndexSegmentMap[v.Key]; !ok {
			return nil, services.NewPairUnsupportedError(v)
		}
		values[v.Key] = v.Value
	}

	var v interface{}
	var ok bool

	// Parse pre-defined pairs
	v, ok = values[ps.Context]
	if ok {
		result.Context = v.(context.Context)
	} else {
		result.Context = context.Background()
	}

	// Parse meta-defined pairs
	v, ok = values[ps.Context]
	if ok {
		result.HasContext = true
		result.Context = v.(context.Context)
	}
	v, ok = values[ps.ReadCallbackFunc]
	if ok {
		result.HasReadCallbackFunc = true
		result.ReadCallbackFunc = v.(func([]byte))
	}

	return result, nil
}

// AbortSegmentWithContext adds context support for AbortSegment.
func (s *Storage) AbortSegmentWithContext(ctx context.Context, seg segment.Segment, pairs ...*types.Pair) (err error) {
	span, ctx := opentracing.StartSpanFromContext(ctx, "github.com/Xuanwo/storage/services/s3.service.AbortSegment")
	defer span.Finish()

	pairs = append(pairs, ps.WithContext(ctx))
	return s.AbortSegment(seg, pairs...)
}

// CompleteSegmentWithContext adds context support for CompleteSegment.
func (s *Storage) CompleteSegmentWithContext(ctx context.Context, seg segment.Segment, pairs ...*types.Pair) (err error) {
	span, ctx := opentracing.StartSpanFromContext(ctx, "github.com/Xuanwo/storage/services/s3.service.CompleteSegment")
	defer span.Finish()

	pairs = append(pairs, ps.WithContext(ctx))
	return s.CompleteSegment(seg, pairs...)
}

// DeleteWithContext adds context support for Delete.
func (s *Storage) DeleteWithContext(ctx context.Context, path string, pairs ...*types.Pair) (err error) {
	span, ctx := opentracing.StartSpanFromContext(ctx, "github.com/Xuanwo/storage/services/s3.service.Delete")
	defer span.Finish()

	pairs = append(pairs, ps.WithContext(ctx))
	return s.Delete(path, pairs...)
}

// InitIndexSegmentWithContext adds context support for InitIndexSegment.
func (s *Storage) InitIndexSegmentWithContext(ctx context.Context, path string, pairs ...*types.Pair) (seg segment.Segment, err error) {
	span, ctx := opentracing.StartSpanFromContext(ctx, "github.com/Xuanwo/storage/services/s3.service.InitIndexSegment")
	defer span.Finish()

	pairs = append(pairs, ps.WithContext(ctx))
	return s.InitIndexSegment(path, pairs...)
}

// ListDirWithContext adds context support for ListDir.
func (s *Storage) ListDirWithContext(ctx context.Context, path string, pairs ...*types.Pair) (err error) {
	span, ctx := opentracing.StartSpanFromContext(ctx, "github.com/Xuanwo/storage/services/s3.service.ListDir")
	defer span.Finish()

	pairs = append(pairs, ps.WithContext(ctx))
	return s.ListDir(path, pairs...)
}

// ListPrefixWithContext adds context support for ListPrefix.
func (s *Storage) ListPrefixWithContext(ctx context.Context, prefix string, pairs ...*types.Pair) (err error) {
	span, ctx := opentracing.StartSpanFromContext(ctx, "github.com/Xuanwo/storage/services/s3.service.ListPrefix")
	defer span.Finish()

	pairs = append(pairs, ps.WithContext(ctx))
	return s.ListPrefix(prefix, pairs...)
}

// ListPrefixSegmentsWithContext adds context support for ListPrefixSegments.
func (s *Storage) ListPrefixSegmentsWithContext(ctx context.Context, path string, pairs ...*types.Pair) (err error) {
	span, ctx := opentracing.StartSpanFromContext(ctx, "github.com/Xuanwo/storage/services/s3.service.ListPrefixSegments")
	defer span.Finish()

	pairs = append(pairs, ps.WithContext(ctx))
	return s.ListPrefixSegments(path, pairs...)
}

// MetadataWithContext adds context support for Metadata.
func (s *Storage) MetadataWithContext(ctx context.Context, pairs ...*types.Pair) (m metadata.StorageMeta, err error) {
	span, ctx := opentracing.StartSpanFromContext(ctx, "github.com/Xuanwo/storage/services/s3.service.Metadata")
	defer span.Finish()

	pairs = append(pairs, ps.WithContext(ctx))
	return s.Metadata(pairs...)
}

// ReadWithContext adds context support for Read.
func (s *Storage) ReadWithContext(ctx context.Context, path string, pairs ...*types.Pair) (r io.ReadCloser, err error) {
	span, ctx := opentracing.StartSpanFromContext(ctx, "github.com/Xuanwo/storage/services/s3.service.Read")
	defer span.Finish()

	pairs = append(pairs, ps.WithContext(ctx))
	return s.Read(path, pairs...)
}

// StatWithContext adds context support for Stat.
func (s *Storage) StatWithContext(ctx context.Context, path string, pairs ...*types.Pair) (o *types.Object, err error) {
	span, ctx := opentracing.StartSpanFromContext(ctx, "github.com/Xuanwo/storage/services/s3.service.Stat")
	defer span.Finish()

	pairs = append(pairs, ps.WithContext(ctx))
	return s.Stat(path, pairs...)
}

// WriteWithContext adds context support for Write.
func (s *Storage) WriteWithContext(ctx context.Context, path string, r io.Reader, pairs ...*types.Pair) (err error) {
	span, ctx := opentracing.StartSpanFromContext(ctx, "github.com/Xuanwo/storage/services/s3.service.Write")
	defer span.Finish()

	pairs = append(pairs, ps.WithContext(ctx))
	return s.Write(path, r, pairs...)
}

// WriteIndexSegmentWithContext adds context support for WriteIndexSegment.
func (s *Storage) WriteIndexSegmentWithContext(ctx context.Context, seg segment.Segment, r io.Reader, index int, size int64, pairs ...*types.Pair) (err error) {
	span, ctx := opentracing.StartSpanFromContext(ctx, "github.com/Xuanwo/storage/services/s3.service.WriteIndexSegment")
	defer span.Finish()

	pairs = append(pairs, ps.WithContext(ctx))
	return s.WriteIndexSegment(seg, r, index, size, pairs...)
}

// AbortSegmentWithContext adds context support for AbortSegment.
func (s *Storage) AbortSegmentWithContext(ctx context.Context, seg segment.Segment, pairs ...*types.Pair) (err error) {
	span, ctx := opentracing.StartSpanFromContext(ctx, "github.com/Xuanwo/storage/services/s3.storage.AbortSegment")
	defer span.Finish()

	pairs = append(pairs, ps.WithContext(ctx))
	return s.AbortSegment(seg, pairs...)
}

// CompleteSegmentWithContext adds context support for CompleteSegment.
func (s *Storage) CompleteSegmentWithContext(ctx context.Context, seg segment.Segment, pairs ...*types.Pair) (err error) {
	span, ctx := opentracing.StartSpanFromContext(ctx, "github.com/Xuanwo/storage/services/s3.storage.CompleteSegment")
	defer span.Finish()

	pairs = append(pairs, ps.WithContext(ctx))
	return s.CompleteSegment(seg, pairs...)
}

// DeleteWithContext adds context support for Delete.
func (s *Storage) DeleteWithContext(ctx context.Context, path string, pairs ...*types.Pair) (err error) {
	span, ctx := opentracing.StartSpanFromContext(ctx, "github.com/Xuanwo/storage/services/s3.storage.Delete")
	defer span.Finish()

	pairs = append(pairs, ps.WithContext(ctx))
	return s.Delete(path, pairs...)
}

// InitIndexSegmentWithContext adds context support for InitIndexSegment.
func (s *Storage) InitIndexSegmentWithContext(ctx context.Context, path string, pairs ...*types.Pair) (seg segment.Segment, err error) {
	span, ctx := opentracing.StartSpanFromContext(ctx, "github.com/Xuanwo/storage/services/s3.storage.InitIndexSegment")
	defer span.Finish()

	pairs = append(pairs, ps.WithContext(ctx))
	return s.InitIndexSegment(path, pairs...)
}

// ListDirWithContext adds context support for ListDir.
func (s *Storage) ListDirWithContext(ctx context.Context, path string, pairs ...*types.Pair) (err error) {
	span, ctx := opentracing.StartSpanFromContext(ctx, "github.com/Xuanwo/storage/services/s3.storage.ListDir")
	defer span.Finish()

	pairs = append(pairs, ps.WithContext(ctx))
	return s.ListDir(path, pairs...)
}

// ListPrefixWithContext adds context support for ListPrefix.
func (s *Storage) ListPrefixWithContext(ctx context.Context, prefix string, pairs ...*types.Pair) (err error) {
	span, ctx := opentracing.StartSpanFromContext(ctx, "github.com/Xuanwo/storage/services/s3.storage.ListPrefix")
	defer span.Finish()

	pairs = append(pairs, ps.WithContext(ctx))
	return s.ListPrefix(prefix, pairs...)
}

// ListPrefixSegmentsWithContext adds context support for ListPrefixSegments.
func (s *Storage) ListPrefixSegmentsWithContext(ctx context.Context, path string, pairs ...*types.Pair) (err error) {
	span, ctx := opentracing.StartSpanFromContext(ctx, "github.com/Xuanwo/storage/services/s3.storage.ListPrefixSegments")
	defer span.Finish()

	pairs = append(pairs, ps.WithContext(ctx))
	return s.ListPrefixSegments(path, pairs...)
}

// MetadataWithContext adds context support for Metadata.
func (s *Storage) MetadataWithContext(ctx context.Context, pairs ...*types.Pair) (m metadata.StorageMeta, err error) {
	span, ctx := opentracing.StartSpanFromContext(ctx, "github.com/Xuanwo/storage/services/s3.storage.Metadata")
	defer span.Finish()

	pairs = append(pairs, ps.WithContext(ctx))
	return s.Metadata(pairs...)
}

// ReadWithContext adds context support for Read.
func (s *Storage) ReadWithContext(ctx context.Context, path string, pairs ...*types.Pair) (r io.ReadCloser, err error) {
	span, ctx := opentracing.StartSpanFromContext(ctx, "github.com/Xuanwo/storage/services/s3.storage.Read")
	defer span.Finish()

	pairs = append(pairs, ps.WithContext(ctx))
	return s.Read(path, pairs...)
}

// StatWithContext adds context support for Stat.
func (s *Storage) StatWithContext(ctx context.Context, path string, pairs ...*types.Pair) (o *types.Object, err error) {
	span, ctx := opentracing.StartSpanFromContext(ctx, "github.com/Xuanwo/storage/services/s3.storage.Stat")
	defer span.Finish()

	pairs = append(pairs, ps.WithContext(ctx))
	return s.Stat(path, pairs...)
}

// WriteWithContext adds context support for Write.
func (s *Storage) WriteWithContext(ctx context.Context, path string, r io.Reader, pairs ...*types.Pair) (err error) {
	span, ctx := opentracing.StartSpanFromContext(ctx, "github.com/Xuanwo/storage/services/s3.storage.Write")
	defer span.Finish()

	pairs = append(pairs, ps.WithContext(ctx))
	return s.Write(path, r, pairs...)
}

// WriteIndexSegmentWithContext adds context support for WriteIndexSegment.
func (s *Storage) WriteIndexSegmentWithContext(ctx context.Context, seg segment.Segment, r io.Reader, index int, size int64, pairs ...*types.Pair) (err error) {
	span, ctx := opentracing.StartSpanFromContext(ctx, "github.com/Xuanwo/storage/services/s3.storage.WriteIndexSegment")
	defer span.Finish()

	pairs = append(pairs, ps.WithContext(ctx))
	return s.WriteIndexSegment(seg, r, index, size, pairs...)
}
