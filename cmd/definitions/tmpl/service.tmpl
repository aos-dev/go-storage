// Code generated by go generate via internal/cmd/service; DO NOT EDIT.
package {{ .Name }}

import (
    "context"
    "io"

    "github.com/aos-dev/go-storage/v2/pkg/endpoint"
    "github.com/aos-dev/go-storage/v2/pkg/credential"
    "github.com/aos-dev/go-storage/v2/pkg/httpclient"
    "github.com/aos-dev/go-storage/v2/services"
    . "github.com/aos-dev/go-storage/v2/types"
)

var _ credential.Provider
var _ endpoint.Provider
var _ Storager
var _ services.ServiceError
var _ httpclient.Options

// Type is the type for {{ .Name }}
const Type = "{{ .Name }}"

// Service available pairs.
const (
{{- range $_, $v := .Pairs }}
    {{- if not $v.Global }}
    {{ $v.Description }}
    {{ $v.FullName }} = "{{ $.Name }}_{{ $v.Name }}"
    {{- end }}
{{- end }}
)

{{- range $_, $v := .Pairs }}
{{- if not $v.Global }}
{{- $pname := $v.Name | toPascal }}
// With{{ $pname }} will apply {{ $v.Name }} value to Options
{{ $v.Description }}
func With{{ $pname }}(v {{ $v.Type }}) Pair {
        return Pair{
        Key: {{ $v.FullName }},
        Value: v,
    }
}
{{- end }}
{{- end }}


{{- range $_, $v := .Infos }}
    {{- if not $v.Global }}
    {{ $pname := $v.Name | toPascal }}
    {{- if $v.DisplayName }}
        {{ $pname = $v.DisplayName }}
    {{- end }}
    {{ $serviceName := printf "%s%s" ($v.Scope | toPascal) ($v.Category | toPascal) }}
    {{- if eq $v.Scope "object" }}
        {{ $serviceName = "Object" }}
    {{- end }}
    // Get{{ $pname }} will get {{ $v.Name }} value from metadata.
    func Get{{ $pname }}(m *{{ $serviceName }}) ({{ $v.Type }}, bool)  {
    v, ok := m.Get("{{ $.Name }}-{{ $v.Name }}")
    if !ok {
    {{- if $v.ZeroValue }}
        return {{ $v.ZeroValue }}, false
    {{- else }}
        return {{ $v.Type | zeroValue }}, false
    {{- end }}
    }
    return v.({{ $v.Type }}), true
    }

    // set{{ $v.Name }} will set {{ $v.Name }} value into metadata.
    func set{{ $pname }}(m *{{ $serviceName }}, v {{ $v.Type }}) *{{ $serviceName }} {
    return m.Set("{{ $.Name }}-{{ $v.Name }}", v)
    }
    {{- end }}
{{- end }}

{{- range $_, $v := .Namespaces }}
    {{- template "pair_new" makeSlice ( $v.Name | toPascal ) $v.New }}
    {{- template "pairs" makeSlice $v.Name $v.Funcs }}
    {{- template "functions" makeSlice $v.Name $v.Funcs }}
{{- end }}

{{- define "pairs" }}
    {{- $pn := index . 0 | toPascal }}
    {{- $data := index . 1 }}

    {{- range $_, $v := $data }}
        {{- template "pair" makeSlice $pn $v}}
    {{- end }}
{{- end}}

{{- define "pair_new" }}
    {{- $pn := index . 0 }}
    {{- $fn := index . 1 }}

    {{- $fnk := $fn.Name | toPascal }}

    // pair{{ $pn }}{{ $fnk }} is the parsed struct
    type pair{{ $pn }}{{$fnk}} struct {
        pairs []Pair

        // Required pairs
        {{- range $_, $pair := $fn.Required }}
        Has{{ $pair.Name | toPascal }}   bool
        {{ $pair.Name | toPascal }}    {{ $pair.Type }}
        {{- end }}
        // Optional pairs
        {{- range $_, $pair := $fn.Optional }}
        Has{{ $pair.Name | toPascal }}   bool
        {{ $pair.Name | toPascal }}      {{ $pair.Type }}
        {{- end }}
        // Generated pairs
        {{- range $_, $pair := $fn.Generated }}
        Has{{ $pair.Name | toPascal }}   bool
        {{ $pair.Name | toPascal }}    {{ $pair.Type }}
        {{- end }}
    }

// parsePair{{ $pn }}{{ $fnk }} will parse Pair slice into *pair{{ $pn }}{{ $fnk }}
func parsePair{{ $pn }}{{ $fnk }}(opts []Pair) (*pair{{ $pn }}{{ $fnk }}, error) {
    result := &pair{{ $pn }}{{ $fnk }}{
        pairs: opts,
    }

    for _, v := range opts {
        switch v.Key {
        {{- range $_, $pair := $fn.Required }}
        case "{{$pair.Name}}":
            result.Has{{ $pair.Name | toPascal }} = true
            result.{{ $pair.Name | toPascal }} = v.Value.({{ $pair.Type }})
        {{- end }}
        {{- range $_, $pair := $fn.Optional }}
        case "{{$pair.Name}}":
            result.Has{{ $pair.Name | toPascal }} = true
            result.{{ $pair.Name | toPascal }} = v.Value.({{ $pair.Type }})
        {{- end }}
        {{- range $_, $pair := $fn.Generated }}
        case "{{$pair.Name}}":
            value, ok := convert{{ $fnk }}{{ $pair.Name | toPascal }}(v.Value.({{ $pair.Type }}))
            if ok {
                result.Has{{ $pair.Name | toPascal }} = true
                result.{{ $pair.Name | toPascal }} = value
            } else {
                 result.Has{{ $pair.Name | toPascal }} = false
            }
        {{- end }}
        }
    }

    {{- range $_, $pair := $fn.Required }}
    if !result.Has{{- $pair.FullName -}} {
        return nil, services.NewPairRequiredError({{- $pair.FullName -}})
    }
    {{- end }}

    return result, nil
}
{{- end }}

{{- define "pair" }}
    {{- $pn := index . 0 }}
    {{- $fn := index . 1 }}

    {{- $fnk := $fn.Name | toPascal }}

    // pair{{ $pn }}{{ $fnk }} is the parsed struct
    type pair{{ $pn }}{{ $fnk }} struct {
        pairs []Pair

        // Required pairs
        {{- range $_, $pair := $fn.Required }}
        Has{{ $pair.Name | toPascal }}   bool
        {{ $pair.Name | toPascal }}    {{ $pair.Type }}
        {{- end }}
        // Optional pairs
        {{- range $_, $pair := $fn.Optional }}
        Has{{ $pair.Name | toPascal }}   bool
        {{ $pair.Name | toPascal }}      {{ $pair.Type }}
        {{- end }}
        // Generated pairs
        {{- range $_, $pair := $fn.Generated }}
        Has{{ $pair.Name | toPascal }}   bool
        {{ $pair.Name | toPascal }}    {{ $pair.Type }}
        {{- end }}
    }

// parsePair{{ $pn }}{{ $fnk }} will parse Pair slice into *pair{{ $pn }}{{ $fnk }}
func (s *{{ $pn }})parsePair{{ $pn }}{{ $fnk }}(opts []Pair) (*pair{{ $pn }}{{ $fnk }}, error) {
    result := &pair{{ $pn }}{{ $fnk }}{
        pairs: opts,
    }

    for _, v := range opts {
        switch v.Key {
        {{- range $_, $pair := $fn.Required }}
        case "{{$pair.Name}}":
            result.Has{{ $pair.Name | toPascal }} = true
            result.{{ $pair.Name | toPascal }} = v.Value.({{ $pair.Type }})
        {{- end }}
        {{- range $_, $pair := $fn.Optional }}
        case "{{$pair.Name}}":
            result.Has{{ $pair.Name | toPascal }} = true
            result.{{ $pair.Name | toPascal }} = v.Value.({{ $pair.Type }})
        {{- end }}
        {{- range $_, $pair := $fn.Generated }}
        case "{{$pair.Name}}":
            value, ok := s.convert{{ $fnk }}{{ $pair.Name | toPascal }}(v.Value.({{ $pair.Type }}))
            if ok {
                result.Has{{ $pair.Name | toPascal }} = true
                result.{{ $pair.Name | toPascal }} = value
            } else {
                if s.pairPolicy.All || s.pairPolicy.{{ $fnk }} || s.pairPolicy.{{ $fnk }}{{ $pair.Name | toPascal }} {
                    return nil, services.NewPairUnsupportedError(v)
                }
            }
        {{- end }}
        default:
            if s.pairPolicy.All || s.pairPolicy.{{ $fnk }} {
                return nil, services.NewPairUnsupportedError(v)
            }
        }
    }

    {{- range $_, $pair := $fn.Required }}
    if !result.Has{{ $pair.Name | toPascal }} {
        return nil, services.NewPairRequiredError({{- $pair.FullName -}})
    }
    {{- end }}

    return result, nil
}
{{- end }}

{{- define "functions" }}
    {{- $pn := index . 0 | toPascal }}
    {{- $data := index . 1 }}

    {{- range $_, $v := $data }}
        {{- template "function" makeSlice $pn $v}}
    {{- end }}
{{- end }}

{{- define "function" }}
    {{- $pn := index . 0 }}
    {{- $fn := index . 1 }}

    {{ $fnk := $fn.Name | toPascal }}

    // {{ $fnk }} {{ $fn.Description }}
    //
    // This function will create a context by default.
    func (s *{{$pn}}) {{ $fnk }}({{$fn.Params.String}}) ({{$fn.Results.String}}) {
        ctx := context.Background()
        return s.{{ $fnk }}WithContext(ctx, {{$fn.Params.Caller}})
    }

    // {{ $fnk }}WithContext {{ $fn.Description }}
    func (s *{{$pn}}) {{ $fnk }}WithContext(ctx context.Context, {{$fn.Params.String}}) ({{$fn.Results.String}}) {
        defer func(){
            {{- $path := $fn.Params.PathCaller }}
            {{- if and (eq $path "") (eq $pn "Service") }}
                {{ $path = ",\"\"" }}
            {{- end }}
            err = s.formatError("{{$fn.Name}}", err {{ $path }} )
        }()
        var opt *pair{{ $pn }}{{ $fnk }}
        opt, err = s.parsePair{{ $pn }}{{ $fnk }}(pairs)
        if err != nil {
            return
        }

        return s.{{  $fn.Name | toCamel }}(ctx, {{$fn.Params.TrimLast.CallerEndswithComma}} opt)
    }
{{- end }}