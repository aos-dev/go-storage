// Code generated by go generate internal/cmd; DO NOT EDIT.
package types

import (
	"fmt"
	"sync"
	"time"
)

// Field index in object bit
const (
	objectIndexContentMd5   uint64 = 1 << 0
	objectIndexContentType  uint64 = 1 << 1
	objectIndexEtag         uint64 = 1 << 2
	objectIndexID           uint64 = 1 << 3
	objectIndexLinkTarget   uint64 = 1 << 4
	objectIndexMode         uint64 = 1 << 5
	objectIndexMultipartID  uint64 = 1 << 6
	objectIndexPath         uint64 = 1 << 7
	objectIndexSize         uint64 = 1 << 8
	objectIndexStorageClass uint64 = 1 << 9
	objectIndexUpdatedAt    uint64 = 1 << 10
)

type Object struct {
	contentMd5  string
	contentType string
	etag        string
	// ID is the unique key in storage.
	ID string
	// LinkTarget is the symlink target for link object.
	linkTarget string
	Mode       ObjectMode
	// MultipartID is the part id of part object.
	multipartID string
	// Path is either the absolute path or the relative path towards storage's WorkDir depends on user's input.
	Path         string
	size         int64
	storageClass string
	updatedAt    time.Time

	// client is the client in which Object is alive.
	client Storager
	// m stores storage related metadata.
	meta map[string]interface{}

	// bit used as a bitmap for object value, 0 means not set, 1 means set
	bit  uint64
	done uint32
	m    sync.Mutex
}

func (o *Object) GetContentMd5() (string, bool) {
	o.stat()

	if o.bit&objectIndexContentMd5 != 0 {
		return o.contentMd5, true
	}

	return "", false
}

func (o *Object) MustGetContentMd5() string {
	o.stat()

	if o.bit&objectIndexContentMd5 == 0 {
		panic(fmt.Sprintf("object content-md5 is not set"))
	}
	return o.contentMd5
}

func (o *Object) SetContentMd5(v string) *Object {
	o.contentMd5 = v
	o.bit |= objectIndexContentMd5
	return o
}

func (o *Object) GetContentType() (string, bool) {
	o.stat()

	if o.bit&objectIndexContentType != 0 {
		return o.contentType, true
	}

	return "", false
}

func (o *Object) MustGetContentType() string {
	o.stat()

	if o.bit&objectIndexContentType == 0 {
		panic(fmt.Sprintf("object content-type is not set"))
	}
	return o.contentType
}

func (o *Object) SetContentType(v string) *Object {
	o.contentType = v
	o.bit |= objectIndexContentType
	return o
}

func (o *Object) GetEtag() (string, bool) {
	o.stat()

	if o.bit&objectIndexEtag != 0 {
		return o.etag, true
	}

	return "", false
}

func (o *Object) MustGetEtag() string {
	o.stat()

	if o.bit&objectIndexEtag == 0 {
		panic(fmt.Sprintf("object etag is not set"))
	}
	return o.etag
}

func (o *Object) SetEtag(v string) *Object {
	o.etag = v
	o.bit |= objectIndexEtag
	return o
}
func (o *Object) GetID() string {
	return o.ID
}

func (o *Object) SetID(v string) *Object {
	o.ID = v
	return o
}

func (o *Object) GetLinkTarget() (string, bool) {
	o.stat()

	if o.bit&objectIndexLinkTarget != 0 {
		return o.linkTarget, true
	}

	return "", false
}

func (o *Object) MustGetLinkTarget() string {
	o.stat()

	if o.bit&objectIndexLinkTarget == 0 {
		panic(fmt.Sprintf("object link-target is not set"))
	}
	return o.linkTarget
}

func (o *Object) SetLinkTarget(v string) *Object {
	o.linkTarget = v
	o.bit |= objectIndexLinkTarget
	return o
}
func (o *Object) GetMode() ObjectMode {
	return o.Mode
}

func (o *Object) SetMode(v ObjectMode) *Object {
	o.Mode = v
	return o
}

func (o *Object) GetMultipartID() (string, bool) {
	o.stat()

	if o.bit&objectIndexMultipartID != 0 {
		return o.multipartID, true
	}

	return "", false
}

func (o *Object) MustGetMultipartID() string {
	o.stat()

	if o.bit&objectIndexMultipartID == 0 {
		panic(fmt.Sprintf("object multipart-id is not set"))
	}
	return o.multipartID
}

func (o *Object) SetMultipartID(v string) *Object {
	o.multipartID = v
	o.bit |= objectIndexMultipartID
	return o
}
func (o *Object) GetPath() string {
	return o.Path
}

func (o *Object) SetPath(v string) *Object {
	o.Path = v
	return o
}

func (o *Object) GetSize() (int64, bool) {
	o.stat()

	if o.bit&objectIndexSize != 0 {
		return o.size, true
	}

	return 0, false
}

func (o *Object) MustGetSize() int64 {
	o.stat()

	if o.bit&objectIndexSize == 0 {
		panic(fmt.Sprintf("object size is not set"))
	}
	return o.size
}

func (o *Object) SetSize(v int64) *Object {
	o.size = v
	o.bit |= objectIndexSize
	return o
}

func (o *Object) GetStorageClass() (string, bool) {
	o.stat()

	if o.bit&objectIndexStorageClass != 0 {
		return o.storageClass, true
	}

	return "", false
}

func (o *Object) MustGetStorageClass() string {
	o.stat()

	if o.bit&objectIndexStorageClass == 0 {
		panic(fmt.Sprintf("object storage-class is not set"))
	}
	return o.storageClass
}

func (o *Object) SetStorageClass(v string) *Object {
	o.storageClass = v
	o.bit |= objectIndexStorageClass
	return o
}

func (o *Object) GetUpdatedAt() (time.Time, bool) {
	o.stat()

	if o.bit&objectIndexUpdatedAt != 0 {
		return o.updatedAt, true
	}

	return time.Time{}, false
}

func (o *Object) MustGetUpdatedAt() time.Time {
	o.stat()

	if o.bit&objectIndexUpdatedAt == 0 {
		panic(fmt.Sprintf("object updated-at is not set"))
	}
	return o.updatedAt
}

func (o *Object) SetUpdatedAt(v time.Time) *Object {
	o.updatedAt = v
	o.bit |= objectIndexUpdatedAt
	return o
}

func (o *Object) clone(xo *Object) {
	o.contentMd5 = xo.contentMd5
	o.contentType = xo.contentType
	o.etag = xo.etag
	o.ID = xo.ID
	o.linkTarget = xo.linkTarget
	o.Mode = xo.Mode
	o.multipartID = xo.multipartID
	o.Path = xo.Path
	o.size = xo.size
	o.storageClass = xo.storageClass
	o.updatedAt = xo.updatedAt

	o.meta = xo.meta

	o.bit = xo.bit
}
